
#include <BluetoothSerial.h>   // Library for Bluetooth communication
#include <math.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd (0x27, 16, 2);
BluetoothSerial SerialBT;


// Motor A
int ena_pin = 13;
int in1_pin = 12;
int in2_pin = 14;
// Motor B
int in3_pin = 27;
int in4_pin = 26;
int enb_pin = 25;

// IR front and back word
int IR_F = 4;
int IR_B = 2;

int buzzer = 0;
int led = 0;

char command = 'S';
int speed = 0;

// Flag to interrupt motor control
volatile bool interruptFlag = false;

// Define the pin for the IR sensor for each wheel
const int FrontleftIRSensorPin = 34;
const int FrontRightIRSensorPin = 15;
const int BackleftIRSensorPin = 35;
const int BackRightIRSensorPin = 32;


// Define constants for the wheel and tick counting
const float wheelRadius = 6.5;     // Radius of the wheel in meters (e.g., 10 cm)
const int ticksPerRevolution = 8;  // Number of ticks per revolution (depends on the number of markers)
const float wheelBase = 12;

// Variables to keep track of ticks for each wheel
volatile long leftWheelTicks = 0;
volatile long rightWheelTicks = 0;

// Interrupt Service Routine (ISR) for left wheel IR sensor
void leftWheelTick() {
  leftWheelTicks++;
}

// Interrupt Service Routine (ISR) for right wheel IR sensor
void rightWheelTick() {
  rightWheelTicks++;
}

// Function to calculate distance traveled
float getDistance(long ticks, float wheelRadius, int ticksPerRevolution) {
  // Calculate the circumference of the wheel
  float wheelCircumference = 2 * M_PI * wheelRadius;

  // Calculate distance traveled
  float distance = (float(ticks) / ticksPerRevolution) * wheelCircumference;

  return distance;  // Return distance in meters
}

void moveForward(int intensity_A, int intensity_B) {
  // Motor A forward
  digitalWrite(in1_pin, LOW);
  digitalWrite(in2_pin, HIGH);
  analogWrite(ena_pin, intensity_A);

  // Motor B forward
  digitalWrite(in3_pin, LOW);
  digitalWrite(in4_pin, HIGH);
  analogWrite(enb_pin, intensity_B);
}

void moveBackward(int intensity_A, int intensity_B) {
  // Motor A backward
  digitalWrite(in1_pin, HIGH);
  digitalWrite(in2_pin, LOW);
  analogWrite(ena_pin, intensity_A);

  // Motor B backward
  digitalWrite(in3_pin, HIGH);
  digitalWrite(in4_pin, LOW);
  analogWrite(enb_pin, intensity_B);
}

void turnLeft(int intensity_A, int intensity_B) {
  // Motor A stop
  analogWrite(ena_pin, intensity_A);
  digitalWrite(in1_pin, HIGH);
  digitalWrite(in2_pin, LOW);

  // Motor B forward
  digitalWrite(in3_pin, LOW);
  digitalWrite(in4_pin, HIGH);
  analogWrite(enb_pin, intensity_B);
}

void turnRight(int intensity_A, int intensity_B) {
  // Motor B stop
  analogWrite(enb_pin, intensity_B);
  digitalWrite(in3_pin, HIGH);
  digitalWrite(in4_pin, LOW);

  // Motor A forward
  digitalWrite(in1_pin, LOW);
  digitalWrite(in2_pin, HIGH);
  analogWrite(ena_pin, intensity_A);
}

void stopMotors() {
  // Motor A stop
  analogWrite(ena_pin, 0);

  // Motor B stop
  analogWrite(enb_pin, 0);
}

// Function that runs automatically when detecting any IR sensor going low
void onSensorChange() {
  interruptFlag = true;
  if (digitalRead(IR_F) == LOW && digitalRead(IR_B) == HIGH) {
    moveBackward(111, 111);
  } else if (digitalRead(IR_F) == HIGH && digitalRead(IR_B) == LOW) {
    moveForward(111, 111);
  }
}

void setup() {
  // Set all motor pins as low
  digitalWrite(in1_pin, LOW);
  digitalWrite(in2_pin, LOW);
  digitalWrite(ena_pin, LOW);
  digitalWrite(in3_pin, LOW);
  digitalWrite(in4_pin, LOW);
  digitalWrite(enb_pin, LOW);
  // Begins serial printing
  Serial.begin(115200);

  // Starts bluetooth serial
  if (!SerialBT.begin("esp32")) {  // Check if Bluetooth starts properly
    Serial.println("An error occurred initializing Bluetooth");
  } else {
    Serial.println("Bluetooth initialized. Device is ready to pair.");
  }

  // Sets econder IR sensor pins as input
  pinMode(FrontleftIRSensorPin, INPUT);
  pinMode(FrontRightIRSensorPin, INPUT);
  pinMode(BackleftIRSensorPin, INPUT);
  pinMode(BackRightIRSensorPin, INPUT);

  // Attach interrupts to the IR sensor pins
  attachInterrupt(digitalPinToInterrupt(FrontleftIRSensorPin), leftWheelTick, RISING);    // Detect rising edge for the left wheel
  attachInterrupt(digitalPinToInterrupt(FrontRightIRSensorPin), rightWheelTick, RISING);  // Detect rising edge for the right wheel
  attachInterrupt(digitalPinToInterrupt(BackleftIRSensorPin), leftWheelTick, RISING);     // Detect rising edge for the left wheel
  attachInterrupt(digitalPinToInterrupt(BackRightIRSensorPin), rightWheelTick, RISING);   // Detect rising edge for the right wheel

  // Initialize pins for motors
  pinMode(in1_pin, OUTPUT);
  pinMode(in2_pin, OUTPUT);
  pinMode(ena_pin, OUTPUT);

  pinMode(in3_pin, OUTPUT);
  pinMode(in4_pin, OUTPUT);
  pinMode(enb_pin, OUTPUT);

  Serial.println("Setup complete.");

  // Initialize IR sensor pins
  pinMode(IR_F, INPUT);
  pinMode(IR_B, INPUT);

  // Attach interrupts to front and back IR sensors
  attachInterrupt(digitalPinToInterrupt(IR_F), onSensorChange, FALLING);
  attachInterrupt(digitalPinToInterrupt(IR_B), onSensorChange, FALLING);

  pinMode(buzzer, OUTPUT);
  pinMode(led, OUTPUT);

  lcd.begin();
  lcd.backlight();
}

void loop() {
  if (Serial.available()) {
    SerialBT.write(Serial.read());
  }
  if (SerialBT.available()) {
    Serial.write(SerialBT.read());
    delay(5);

    // Reads the sent command
    String data = SerialBT.readStringUntil('\n');

    if (data.length() > 0) {
      // Extract the direction (first character)
      command = data.charAt(0);

      // Extract the speed (remaining part of the string)
      String speedstr = data.substring(1);
      speed = speedstr.toInt();  // Convert the speed string to integer
    } else {
      command = 'S';
    }

    if (interruptFlag) {
      stopMotors();           // Stop motors if interrupt flag is set
      interruptFlag = false;  // Clear the flag
    }
    
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Speed:");
    lcd.print(speed);
    switch (command) {
      case 'F':  // Move forward
        moveForward(speed, speed);
        break;
      case 'B':  // Move backward
        moveBackward(speed, speed);
        break;
      case 'L':  // Turn left
        turnLeft(speed, speed);
        break;
      case 'R':  // Turn right
        turnRight(speed, speed);
        break;
      case 'S':  // Stop
        stopMotors();
        break;
      case 'A':
        digitalWrite(led, HIGH);
        break;
      case 'T':
        digitalWrite(led, LOW);
        break;
      default:
        stopMotors();
        break;
    }
  } else {
  stopMotors();
  }

  // Calculate the distances traveled by each wheel pair
  float leftWheelDistance = getDistance(leftWheelTicks / 2, wheelRadius, ticksPerRevolution);
  float rightWheelDistance = getDistance(rightWheelTicks / 2, wheelRadius, ticksPerRevolution);

  // Total distance covered by both wheels
  float linearDistance = (leftWheelDistance + rightWheelDistance) / 2;
  // Angle between 2 circular arcs formed by both wheels
  float angularDistance = (rightWheelDistance-leftWheelDistance) / wheelBase;

  // Resetting the ticks for another calculation
  leftWheelTicks = 0;
  rightWheelTicks = 0;
}
